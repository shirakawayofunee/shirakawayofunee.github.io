<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SSTEMY36NM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag("js", new Date());
      gtag("config", "G-SSTEMY36NM");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=yes" />
    <title>相関図 ドラッグ可能な手がかりボード</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
    <style>
      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Courier New", Arial, sans-serif;
        overflow: auto;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        position: relative;
        background: #f0f0f0;
      }

      body::before {
        content: "";
        background: url("img/bg_full.png") center/cover no-repeat fixed;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        box-shadow: inset 0 0 15rem rgba(0, 0, 0, 0.6);
        transition: filter 0.5s;
      }

      body.loaded::before {
        filter: blur(0);
      }

      #board {
        position: relative;
        min-height: 100vh;
        width: 100%;
        pointer-events: none;
        padding: 15px;
      }

      #lines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
      }

      .node, .large-node {
        position: absolute;
        transform: translate(-50%, -50%);
        pointer-events: auto;
        transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.3));
        z-index: 3;
        touch-action: none;
      }

      .node .avatar, .large-node .avatar {
        border: 2px solid #ecf0f1;
        background: url("img/default-avatar.png") top/cover no-repeat;
        border-radius: 3px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s;
        margin: 0 auto 8px;
        display: block;
      }

      .node .label, .large-node .label {
        padding: 6px;
        color: #ecf0f1;
        border-radius: 3px;
        line-height: 1.4;
        word-break: break-word;
        background: rgba(103, 109, 138, 0.8);
        backdrop-filter: blur(2px);
        margin-top: 8px;
      }

      .relation-line {
        stroke: #e74c3c;
        stroke-width: 2;
        stroke-linecap: round;
        fill: none;
        marker-end: url(#arrowhead);
        transition: all 0.3s ease-out;
      }

      .dashed-line {
        stroke-dasharray: 5;
      }

      #lines text {
        fill: #ecf0f1;
        font-family: "MS Gothic", "Courier New", monospace;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }

      #lines tspan {
        white-space: pre;
        letter-spacing: 0.05em;
      }

      #lines rect {
        fill: rgba(26, 34, 85, 0.9);
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        z-index: 2;
      }

      body:not(.loaded) .node, body:not(.loaded) .large-node {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }

      body.loaded .node, body.loaded .large-node {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }

      @media (min-width: 992px) {
        .node { width: 102px; }
        .node .avatar { width: 102px; height: 133px; }
        .node .label { max-width: 102px; font-size: 12px; }
        .large-node { width: 153px; }
        .large-node .avatar { width: 153px; height: 200px; }
        .large-node .label { max-width: 153px; font-size: 12px; }
        #lines text { font-size: 14px; }
        #lines rect { rx: 5; }
      }

      @media (max-width: 991px) and (min-width: 577px) {
        .node { width: 80px; }
        .node .avatar { width: 80px; height: 104px; }
        .node .label { max-width: 80px; font-size: 10px; }
        .large-node { width: 120px; }
        .large-node .avatar { width: 120px; height: 156px; }
        .large-node .label { max-width: 120px; font-size: 11px; }
        #lines text { font-size: 12px; }
        #lines rect { rx: 4; }
      }

      @media (max-width: 576px) {
        #board {
          padding: 10px;
          overflow-x: hidden;
        }
        body::before {
          background-size: cover;
          background-position: center;
          filter: blur(5px);
        }
        .node { width: 60px; }
        .node .avatar { width: 60px; height: 78px; }
        .node .label { max-width: 60px; font-size: 8px; padding: 4px; }
        .large-node { width: 90px; }
        .large-node .avatar { width: 90px; height: 117px; }
        .large-node .label { max-width: 90px; font-size: 9px; padding: 4px; }
        #lines text { font-size: 10px; }
        #lines rect { rx: 3; }
      }
    </style>
  </head>

  <body>
    <div id="board" class="container-fluid">
      <svg id="lines">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c" />
          </marker>
        </defs>
      </svg>

      <div class="row justify-content-center g-2">
        <div class="col-lg-8 col-md-10 col-sm-12">
          <div class="node large-node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar" style="background-image: url('img/id-leopold.jpg')"></div>
            <div class="label">
              警視庁エリート<br />見た目は16～17歳だが、実年齢不明。<br />
              見た目は優れ、常に世を拗ねるような微笑を浮かべている。<br />
              好き嫌いが激しく、享楽主義者でもあるが、細やかで優しい一面も持っている。<br />
              落ち着き払った自信に満ちていて、自信かつ優雅な態度を保ち、性格は八方巧み。
            </div>
          </div>
          <div class="node large-node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar" style="background-image: url('img/id-severo.jpg')"></div>
            <div class="label">
              26歳、容疑者。<br />
              憂いと苦悩、感傷に満ちた女性として偽装して登場する。<br />
              第一印象は礼儀正しく、スイーツ作りに万能であり、少しユーモアのある人物。
            </div>
          </div>
          <div class="node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar"></div>
            <div class="label">J<br />23歳、Lの養女<br />警察庁高官を母に持つの刑事</div>
          </div>
          <div class="node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar"></div>
            <div class="label">
              K<br />Lの母親の隣人のパートナーの園芸師の姪（？<br />
              18歳、Lの養女。Lが一番好き。<br />
              Lへの想いが家族愛か恋愛か自分でもわからない。<br />
              Lが最近ハマっている手作りスイーツ店に長蛇の列でも並びに行く
            </div>
          </div>
          <div class="node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar"></div>
            <div class="label">X<br />連続殺人事件の真犯人 謎の人物</div>
          </div>
          <div class="node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar"></div>
            <div class="label">Y<br />8月14日的死者</div>
          </div>
          <div class="node col-lg-2 col-md-3 col-sm-4 col-6">
            <div class="avatar"
            style="background-image: url('img/id-severoz.jpg')"
            ></div>
            <div class="label">
              真正的S<br />外交官<br />過去の事件でLと因縁がある<br />
              第一印象は礼儀正しく、スイーツ作りに万能であり、少しユーモアのある人物。
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const connections = [
        { from: 0, to: 1, label: "控えめな探求、飼養", dashed: false },
        { from: 0, to: 2, label: "有意培养为继承人", dashed: true },
        { from: 0, to: 3, label: "慈しむ、憐憫", dashed: false },
        { from: 0, to: 4, label: "やり返す", dashed: true },
        { from: 1, to: 4, label: "厭悪", dashed: true },
        { from: 0, to: 6, label: "過去の因縁", dashed: true },
        { from: 1, to: 6, label: "杀害、取代", dashed: true },
      ];

      const state = {
        dragging: false,
        nodes: [],
        resizeTimer: null,
      };

      function initLayout() {
        const board = document.getElementById("board");
        const viewportWidth = window.innerWidth;
        const viewportHeight = Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        );
        const boardHeight = Math.max(board.scrollHeight, viewportHeight);
        const isMobile = viewportWidth <= 576;
        const baseRadius = isMobile
          ? Math.min(viewportWidth, viewportHeight) * 0.35
          : Math.min(viewportWidth, viewportHeight) * 0.25;

        const positions = [
          [0, 0.5], // Leopold
          [1.6, 0.9], // Severo
          [-1.0, 1.2], // J
          [-1.4, -0.5], // j
          [2.6, -1], // X
          [-2.3, 0.5], // Y
          [1.2, -0.8], // ZS
        ];

        state.nodes.forEach((node, index) => {
          const avatar = node.querySelector(".avatar");
          const [dx, dy] = positions[index];
          const x = Math.max(60, Math.min(viewportWidth - 60, viewportWidth / 2 + dx * baseRadius));
          const y = Math.max(80, Math.min(viewportHeight - 80, viewportHeight / 2 + dy * baseRadius));
          Object.assign(node.style, {
            left: `${x}px`,
            top: `${y}px`,
            transform: "translate(-50%, -50%)",
            transition: state.dragging ? "none" : "all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)",
          });
        });

        board.style.minHeight = `${boardHeight}px`;
        document.getElementById("lines").setAttribute("viewBox", `0 0 ${viewportWidth} ${boardHeight}`);
      }

      function drawLines() {
        const svg = document.getElementById("lines");
        const defs = svg.querySelector("defs");
        svg.innerHTML = "";
        svg.appendChild(defs);

        connections.forEach((conn) => {
          if (conn.from >= state.nodes.length || conn.to >= state.nodes.length) return;

          const fromNode = state.nodes[conn.from];
          const toNode = state.nodes[conn.to];
          const fromAvatar = fromNode.querySelector(".avatar");
          const toAvatar = toNode.querySelector(".avatar");
          const fromRect = fromAvatar.getBoundingClientRect();
          const toRect = toAvatar.getBoundingClientRect();
          const boardRect = document.getElementById("board").getBoundingClientRect();

          const start = {
            x: fromRect.left + fromRect.width / 2 - boardRect.left,
            y: fromRect.top + fromRect.height / 2 - boardRect.top,
          };
          const end = {
            x: toRect.left + toRect.width / 2 - boardRect.left,
            y: toRect.top + toRect.height / 2 - boardRect.top,
          };

          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.classList.add("relation-line");
          if (conn.dashed) path.classList.add("dashed-line");

          const isReverse = connections.some(
            (c) => c.from === conn.to && c.to === conn.from && c.label !== conn.label
          );

          if (isReverse) {
            const curvature = 0.3;
            const ctrl = {
              x: (start.x + end.x) / 2 + curvature * (end.y - start.y),
              y: (start.y + end.y) / 2 + curvature * (start.x - end.x),
            };
            path.setAttribute("d", `M ${start.x} ${start.y} Q ${ctrl.x} ${ctrl.y} ${end.x} ${end.y}`);
          } else {
            path.setAttribute("d", `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
          }

          const textGroup = createConnectionLabel(conn.label, start, end, isReverse);
          svg.appendChild(path);
          svg.appendChild(textGroup);
        });
      }

      function createConnectionLabel(text, start, end, isCurve) {
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const padding = 6;

        const lines = text.split(/[、\n]/);
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const labelPos = {
          x: (start.x + end.x) / 2 + Math.cos(angle) * (isCurve ? 10 : 0),
          y: (start.y + end.y) / 2 + Math.sin(angle) * (isCurve ? 10 : -5),
        };

        const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textEl.setAttribute("x", labelPos.x);
        textEl.setAttribute("y", labelPos.y);
        textEl.setAttribute("text-anchor", "middle");
        textEl.setAttribute("dominant-baseline", "middle");
        textEl.setAttribute("fill", "#ecf0f1");
        textEl.setAttribute("font-size", window.innerWidth <= 576 ? "10px" : "14px");

        lines.forEach((line, index) => {
          if (!line) return;
          const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspan.setAttribute("x", labelPos.x);
          tspan.setAttribute("dy", index === 0 ? "0" : "1.2em");
          tspan.textContent = line;
          textEl.appendChild(tspan);
        });

        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        tempSvg.style.position = "absolute";
        tempSvg.style.visibility = "hidden";
        document.body.appendChild(tempSvg);
        tempSvg.appendChild(textEl);
        const bbox = textEl.getBBox();
        document.body.removeChild(tempSvg);

        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", bbox.x - padding);
        rect.setAttribute("y", bbox.y - padding);
        rect.setAttribute("width", bbox.width + padding * 2);
        rect.setAttribute("height", bbox.height + padding * 2);
        rect.setAttribute("fill", "rgba(26, 34, 85, 0.9)");
        rect.setAttribute("rx", window.innerWidth <= 576 ? "3" : "5");

        group.appendChild(rect);
        group.appendChild(textEl);
        return group;
      }

      function initDragSystem() {
        let dragInfo = null;

        state.nodes.forEach((node) => {
          node.addEventListener("mousedown", startDrag);
          node.addEventListener("touchstart", (e) => {
            e.preventDefault();
            startDrag(e.touches[0]);
          }, { passive: false });
        });

        function startDrag(e) {
          state.dragging = true;
          const targetNode = e.target.closest(".node, .large-node");
          const rect = targetNode.getBoundingClientRect();
          dragInfo = {
            node: targetNode,
            offsetX: e.clientX - rect.left,
            offsetY: e.clientY - rect.top,
          };

          document.addEventListener("mousemove", onDrag);
          document.addEventListener("mouseup", onDragEnd);
          document.addEventListener("touchmove", onTouchDrag, { passive: false });
          document.addEventListener("touchend", onDragEnd);
        }

        function onDrag(e) {
          updatePosition(e.clientX, e.clientY);
        }

        function onTouchDrag(e) {
          e.preventDefault();
          updatePosition(e.touches[0].clientX, e.touches[0].clientY);
        }

        function updatePosition(clientX, clientY) {
          if (!dragInfo) return;
          const { node, offsetX, offsetY } = dragInfo;
          const avatar = node.querySelector(".avatar");
          const boardRect = document.getElementById("board").getBoundingClientRect();
          
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const nodeWidth = node.offsetWidth;
          const nodeHeight = node.offsetHeight;

          const newX = Math.max(nodeWidth / 2, Math.min(
            clientX - offsetX,
            viewportWidth - nodeWidth / 2
          ));
          const newY = Math.max(nodeHeight / 2, Math.min(
            clientY - offsetY,
            viewportHeight - nodeHeight / 2
          ));

          Object.assign(node.style, {
            left: `${newX}px`,
            top: `${newY}px`,
            transform: "translate(-50%, -50%)",
            transition: "none",
          });

          requestAnimationFrame(drawLines);
        }

        function onDragEnd() {
          state.dragging = false;
          dragInfo = null;
          document.removeEventListener("mousemove", onDrag);
          document.removeEventListener("mouseup", onDragEnd);
          document.removeEventListener("touchmove", onTouchDrag);
          document.removeEventListener("touchend", onDragEnd);
        }
      }

      function initResponsive() {
        window.addEventListener("resize", () => {
          clearTimeout(state.resizeTimer);
          state.resizeTimer = setTimeout(() => {
            initLayout();
            drawLines();
          }, 200);
        });
      }

      function initialize() {
        state.nodes = Array.from(document.querySelectorAll(".node, .large-node"));
        if (state.nodes.length === 0) return;

        const bgImage = new Image();
        bgImage.src = "img/bg_full.png";
        bgImage.onload = () => document.body.classList.add("loaded");
        bgImage.onerror = () => document.body.classList.add("loaded");

        initLayout();
        initDragSystem();
        initResponsive();
        drawLines();
        setTimeout(() => document.body.classList.add("loaded"), 3000);
      }

      window.addEventListener("load", initialize);
    </script>
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-analytics.js";
      import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDlcorBh1IJUnelC_8-5bf2i4h--P4q7nE",
        authDomain: "fangkeshuju.firebaseapp.com",
        projectId: "fangkeshuju",
        storageBucket: "fangkeshuju.firebasestorage.app",
        messagingSenderId: "1043722790851",
        appId: "1:1043722790851:web:01cca5afff820eb202ff76",
        measurementId: "G-MGC7KEWX53",
      };

      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
      const db = getFirestore(app);

      async function logPageView() {
        try {
          await addDoc(collection(db, "page_views"), {
            page_title: document.title,
            page_location: window.location.href,
            page_path: window.location.pathname,
            timestamp: serverTimestamp(),
          });
          console.log("Page view logged successfully");
        } catch (error) {
          console.error("Error saving page view: ", error);
        }
      }

      logPageView();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  </body>
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5W78LXJT" height="0" width="0" style="display: none; visibility: hidden"></iframe></noscript>
</html>