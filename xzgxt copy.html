<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SSTEMY36NM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SSTEMY36NM');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>相関図 ドラッグ可能な手がかりボード</title>
    <style>
        /* 基础全局样式 */
        body {
            margin: 0;
            position: relative;
            min-height: 100vh;
            min-width: 100vw;
            font-family: 'Courier New', Arial, sans-serif;
            overflow: auto; /* 确保可以滚动 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* 背景图层 */
        body::before {
            content: '';
            background: url('img/bg_full.png') center/contain no-repeat fixed;
            position: fixed;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            box-shadow: inset 0 0 15rem rgba(0, 0, 0, 0.6);
            filter: blur(10px) brightness(0.9);
            transition: filter 0.5s;
        }

        /* 加载完成状态 */
        body.loaded::before {
            filter: blur(0) !important;
        }

        /* 主画布容器 */
        #board {
            position: relative; /* 改为相对定位 */
            width: 150vw;
            height: 150vh;
            min-width: 1000px;
            overflow: visible;
            pointer-events: none;
        }

        /* 角色节点基础样式 */
        .node {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            width: 102px; /* 默认宽度为小尺寸角色 */
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.3));
            z-index: 3;
            touch-action: none;
        }

        /* 大尺寸角色 (L 和 S) */
        .large-node {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            width: 153px; /* 大尺寸宽度 */
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.3));
            z-index: 3;
            touch-action: none;
        }

        /* 默认尺寸的证件照 */
        .node .avatar {
            width: 102px;
            height: 133px;
            border: 2px solid #ecf0f1;
            background: url('img/default-avatar.png') top/cover;
            border-radius: 3px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            margin: 0 auto 10px;
            display: block;
        }

        /* 大尺寸的证件照 */
        .large-node .avatar {
            width: 153px;
            height: 200px;
            border: 2px solid #ecf0f1;
            background: url('img/default-avatar.png') top/cover;
            border-radius: 3px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            margin: 0 auto 10px;
            display: block;
        }

        .avatar:hover {
            transform: scale(1.05);
        }

        /* 默认尺寸的文字标签 */
        .node .label {
            max-width: 102px;
            padding: 8px;
            color: #ecf0f1;
            border-radius: 3px;
            font-size: 12px;
            line-height: 1.4;
            word-break: break-word;
            z-index: 3;
            position: relative;
            background: rgba(103, 109, 138, 0.8) !important; /* #676D8A with 0.8 opacity */
            backdrop-filter: blur(2px);
        }

        /* 大尺寸的文字标签 (L 和 S) */
        .large-node .label {
            max-width: 153px;
            padding: 8px;
            color: #ecf0f1;
            border-radius: 3px;
            font-size: 12px;
            line-height: 1.4;
            word-break: break-word;
            z-index: 3;
            position: relative;
            background: rgba(103, 109, 138, 0.8) !important;
            backdrop-filter: blur(2px);
        }

        /* 关系连线 */
        .relation-line {
            stroke: #e74c3c !important;
            stroke-width: 2;
            stroke-linecap: round;
            fill: none;
            marker-end: url(#arrowhead);
            transition: all 0.3s ease-out;
            z-index: 1 !important;
        }

        .dashed-line {
            stroke-dasharray: 5;
        }

        /* SVG 关系标签 */
        #lines text {
            fill: #ecf0f1;
            font-family: 'MS Gothic', 'Courier New', monospace;
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
            z-index: 3;
        }

        #lines tspan {
            white-space: pre;
            letter-spacing: 0.05em;
        }

        #lines rect {
            fill: rgba(26, 34, 85, 0.9); /* #1A2255 with 0.9 opacity */
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
            z-index: 2;
            rx: 5;
        }

        /* 加载过渡动画 */
        body:not(.loaded) .node,
        body:not(.loaded) .large-node {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }

        body.loaded .node,
        body.loaded .large-node {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            #board {
                width: 300vw; /* 进一步扩展画布 */
                height: 300vh;
                min-width: 0; /* 移除桌面端限制 */
            }

            /* 默认尺寸移动端 */
            .node {
                transform: translate(-50%, -50%) !important;
                will-change: transform;
                width: 60px;
                max-width: 20vw !important;
            }

            .node .avatar {
                width: 60px;
                height: 80px;
                max-width: 20vw;
                height: 26vw;
            }

            .node .label {
                max-width: 60px;
                font-size: 8px;
                padding: 3px;
                line-height: 1.2;
                background: rgba(103, 109, 138, 0.8) !important;
            }

            /* 大尺寸移动端 (L 和 S) */
            .large-node {
                transform: translate(-50%, -50%) !important;
                will-change: transform;
                width: 90px;
                max-width: 25vw !important;
            }

            .large-node .avatar {
                width: 90px;
                height: 120px;
                max-width: 25vw;
                height: 33vw;
            }

            .large-node .label {
                max-width: 90px;
                font-size: 9px;
                padding: 3px;
                line-height: 1.2;
                background: rgba(103, 109, 138, 0.8) !important;
            }

            /* 关系标签在移动端调整 */
            #lines text {
                font-size: 10px;
            }

            #lines rect {
                rx: 3;
            }
        }
    </style>
</head>

<body>
    <div id="board">
        <svg id="lines" style="position: absolute; width: 100%; height: 100%">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c" />
                </marker>
            </defs>
        </svg>

        <!-- 人物节点 -->
        <div class="node large-node">
            <div class="avatar" style="background-image: url('img/id-leopold.jpg')"></div>
            <div class="label">
                警視庁エリート
                <br>見た目は16～17歳だが、実年齢不明。<br>
                見た目は優れ、常に世を拗ねるような微笑を浮かべている。<br>
                好き嫌いが激しく、享楽主義者でもあるが、細やかで優しい一面も持っている。<br>
                落ち着き払った自信に満ちていて、自信かつ優雅な態度を保ち、性格は八方巧み。
            </div>
        </div>
        <div class="node large-node">
            <div class="avatar" style="background-image: url('img/id-severo.jpg')"></div>
            <div class="label">
                26歳、容疑者。<br>
                憂いと苦悩、感傷に満ちた女性として偽装して登場する。<br>
                第一印象は礼儀正しく、スイーツ作りに万能であり、少しユーモアのある人物。
            </div>
        </div>
        <div class="node">
            <div class="avatar"></div>
            <div class="label">J<br>
                23歳、Lの養女<br>
                警察庁高官を母に持つの刑事
            </div>
        </div>
        <div class="node">
            <div class="avatar"></div>
            <div class="label">K<br>
                Lの母親の隣人のパートナーの園芸師の姪（？<br>
                18歳、Lの養女。Lが一番好き。<br>
                Lへの想いが家族愛か恋愛か自分でもわからない。<br>
                Lが最近ハマっている手作りスイーツ店に長蛇の列でも並びに行く<br></div>
        </div>
        <div class="node">
            <div class="avatar"></div>
            <div class="label">X<br>
                連続殺人事件の真犯人 謎の人物<br>
            </div>
        </div>
        <div class="node">
            <div class="avatar"></div>
            <div class="label">
                Y<br>
                8月14日的死者<br>
            </div>
        </div>
        <div class="node">
            <div class="avatar"></div>
            <div class="label">
                真正的S<br>
                外交官<br>
                過去の事件でLと因縁がある<br>
                第一印象は礼儀正しく、スイーツ作りに万能であり、少しユーモアのある人物。
            </div>
        </div>
    </div>

    <script>
        const connections = [
            { from: 0, to: 1, label: "控えめな探求、飼養、優しくも支配的", dashed: false },
            { from: 0, to: 2, label: "母女、師弟", dashed: true },
            { from: 0, to: 3, label: "慈しむ、憐憫", dashed: false },
            { from: 0, to: 4, label: "やり返す", dashed: true },
            { from: 1, to: 4, label: "厭悪", dashed: true },
            { from: 3, to: 4, label: "厭悪", dashed: true },
            { from: 3, to: 2, label: "", dashed: false },
            { from: 0, to: 6, label: "過去の因縁", dashed: true },
            { from: 1, to: 6, label: "監視", dashed: true }
        ];

        const state = {
            dragging: false,
            nodes: [],
            resizeTimer: null
        };

        function initLayout() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const isMobile = viewportWidth <= 768;

            console.log(`Viewport: ${viewportWidth}x${viewportHeight}`);
            console.log(`Is Mobile: ${isMobile}`);

            const baseRadius = isMobile
                ? Math.min(viewportWidth, viewportHeight) * 0.3
                : Math.min(viewportWidth, viewportHeight) * 0.25;

            console.log(`Base Radius: ${baseRadius}`);

            const positions = [
                [0, 0],      // Leopold
                [2, 0.4],    // Severo
                [-2.3, 0.5], // J
                [-1.4, -0.5],// K
                [2.6, -1],   // X
                [-1.0, 1.5], // Y
                [1, 1.5]     // ZS
            ];

            state.nodes.forEach((node, index) => {
                const [dx, dy] = positions[index];
                console.log(`Node ${index} Position: [${dx}, ${dy}]`);

                const x = viewportWidth / 2 + dx * baseRadius;
                const y = viewportHeight / 2 + dy * baseRadius;
                console.log(`Node ${index} Calculated Position: [${x}, ${y}]`);

                Object.assign(node.style, {
                    left: `${x}px`,
                    top: `${y}px`,
                    transition: state.dragging ? 'none' : 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)'
                });
            });

            console.log('Layout initialized');
        }

        function drawLines() {
            const svg = document.getElementById('lines');
            svg.innerHTML = '';

            connections.forEach(conn => {
                if (conn.from >= state.nodes.length || conn.to >= state.nodes.length) {
                    console.error(`无效连接索引：${conn.from}→${conn.to}`);
                    return;
                }

                const fromRect = state.nodes[conn.from].getBoundingClientRect();
                const toRect = state.nodes[conn.to].getBoundingClientRect();
                const boardRect = document.getElementById('board').getBoundingClientRect();

                const start = {
                    x: fromRect.left + fromRect.width / 2 - boardRect.left + window.scrollX,
                    y: fromRect.top + fromRect.height / 2 - boardRect.top + window.scrollY
                };
                const end = {
                    x: toRect.left + toRect.width / 2 - boardRect.left + window.scrollX,
                    y: toRect.top + toRect.height / 2 - boardRect.top + window.scrollY
                };

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('relation-line');
                if (conn.dashed) path.classList.add('dashed-line');

                const isReverse = connections.some(c =>
                    c.from === conn.to && c.to === conn.from && c.label !== conn.label
                );

                if (isReverse) {
                    const curvature = 0.3;
                    const ctrl = {
                        x: (start.x + end.x) / 2 + curvature * (end.y - start.y),
                        y: (start.y + end.y) / 2 + curvature * (start.x - end.x)
                    };
                    path.setAttribute('d', `M ${start.x} ${start.y} Q ${ctrl.x} ${ctrl.y} ${end.x} ${end.y}`);
                } else {
                    path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
                }

                const textGroup = createConnectionLabel(conn.label, start, end, isReverse);
                svg.appendChild(path);
                svg.appendChild(textGroup);
            });
        }

        function createConnectionLabel(text, start, end, isCurve) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const padding = 8;
            const lineHeight = 18;

            const lines = text.split(/[、\n]/);

            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            const labelPos = {
                x: (start.x + end.x) / 2 + Math.cos(angle) * (isCurve ? 15 : 0),
                y: (start.y + end.y) / 2 + Math.sin(angle) * (isCurve ? 15 : -5)
            };

            const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textEl.setAttribute('x', labelPos.x);
            textEl.setAttribute('y', labelPos.y);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'middle');
            textEl.setAttribute('fill', '#ecf0f1');
            textEl.setAttribute('font-size', window.innerWidth <= 768 ? '10px' : '14px');

            lines.forEach((line, index) => {
                if (!line) return;
                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.setAttribute('x', labelPos.x);
                tspan.setAttribute('dy', index === 0 ? '0' : '1.2em');
                tspan.textContent = line;
                textEl.appendChild(tspan);
            });

            const tempContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            document.body.appendChild(tempContainer);
            tempContainer.appendChild(textEl);

            const bbox = textEl.getBBox();
            document.body.removeChild(tempContainer);

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', bbox.x - padding);
            rect.setAttribute('y', bbox.y - padding);
            rect.setAttribute('width', bbox.width + padding * 2);
            rect.setAttribute('height', bbox.height + padding * 2);
            rect.setAttribute('fill', 'rgba(26, 34, 85, 0.9)');
            rect.setAttribute('rx', window.innerWidth <= 768 ? '3' : '5');
            rect.setAttribute('stroke', '#2c3e50');
            rect.setAttribute('stroke-width', '1');

            group.appendChild(rect);
            group.appendChild(textEl);

            return group;
        }

        function initDragSystem() {
            let dragInfo = null;

            document.querySelectorAll('.node, .large-node').forEach(node => {
                node.addEventListener('mousedown', startDrag);
                node.addEventListener('touchstart', e => {
                    e.preventDefault();
                    startDrag(e.touches[0]);
                });
            });

            function startDrag(e) {
                state.dragging = true;
                const rect = e.target.closest('.node, .large-node').getBoundingClientRect();
                dragInfo = {
                    node: e.target.closest('.node, .large-node'),
                    offsetX: e.clientX - rect.left,
                    offsetY: e.clientY - rect.top
                };

                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', onDragEnd);
                document.addEventListener('touchmove', onTouchDrag, { passive: false });
                document.addEventListener('touchend', onDragEnd);
            }

            function onDrag(e) {
                updatePosition(e.clientX, e.clientY);
            }

            function onTouchDrag(e) {
                e.preventDefault();
                updatePosition(e.touches[0].clientX, e.touches[0].clientY);
            }

            function updatePosition(clientX, clientY) {
                if (!dragInfo) return;

                const { node, offsetX, offsetY } = dragInfo;
                const newX = clientX - offsetX;
                const newY = clientY - offsetY;

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const nodeWidth = node.offsetWidth;
                const nodeHeight = node.offsetHeight;

                const boundedX = Math.max(nodeWidth / 2, Math.min(newX, viewportWidth - nodeWidth / 2));
                const boundedY = Math.max(nodeHeight / 2, Math.min(newY, viewportHeight - nodeHeight / 2));

                Object.assign(node.style, {
                    left: `${boundedX}px`,
                    top: `${boundedY}px`,
                    transition: 'none'
                });

                requestAnimationFrame(drawLines);
            }

            function onDragEnd() {
                state.dragging = false;
                dragInfo = null;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchmove', onTouchDrag);
                document.removeEventListener('touchend', onDragEnd);
            }
        }

        function initResponsive() {
            window.addEventListener('resize', () => {
                clearTimeout(state.resizeTimer);
                state.resizeTimer = setTimeout(() => {
                    initLayout();
                    drawLines();
                }, 200);
            });
        }

        function initialize() {
            state.nodes = Array.from(document.querySelectorAll('.node, .large-node'));
            if (state.nodes.length === 0) {
                console.error('未找到任何角色节点!');
                return;
            }

            console.log(`Found ${state.nodes.length} nodes`);

            const forceClear = () => {
                document.body.classList.add('loaded');
                console.log('强制清晰化已触发');
            };

            const bgImage = new Image();
            bgImage.src = 'img/bg_full.png';

            bgImage.onload = () => {
                console.log('背景图加载成功');
                document.body.classList.add('loaded');
            };

            bgImage.onerror = (e) => {
                console.error('背景图加载失败:', e);
                forceClear();
            };

            try {
                initLayout();
                initDragSystem();
                initResponsive();
                drawLines();
                console.log('系统初始化完成');
            } catch (error) {
                console.error('初始化过程中发生错误:', error);
                forceClear();
            }

            setTimeout(forceClear, 3000);
        }

        window.addEventListener('load', () => {
            console.log('窗口load事件触发');
            initialize();
        });
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-analytics.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDlcorBh1IJUnelC_8-5bf2i4h--P4q7nE",
            authDomain: "fangkeshuju.firebaseapp.com",
            projectId: "fangkeshuju",
            storageBucket: "fangkeshuju.firebasestorage.app",
            messagingSenderId: "1043722790851",
            appId: "1:1043722790851:web:01cca5afff820eb202ff76",
            measurementId: "G-MGC7KEWX53"
        };

        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db = getFirestore(app);

        async function logPageView() {
            try {
                await addDoc(collection(db, 'page_views'), {
                    page_title: document.title,
                    page_location: window.location.href,
                    page_path: window.location.pathname,
                    timestamp: serverTimestamp()
                });
                console.log('Page view saved to Firestore');
            } catch (error) {
                console.error('Error saving page view: ', error);
            }
        }

        logPageView();

        const images = document.querySelectorAll('img.trackable');
        images.forEach(img => {
            let startTime = null;

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        startTime = Date.now();
                    } else if (startTime) {
                        const duration = (Date.now() - startTime) / 1000;
                        saveImageView(img.src, duration);
                        startTime = null;
                    }
                });
            });

            observer.observe(img);
        });

        async function saveImageView(imageSrc, duration) {
            try {
                await addDoc(collection(db, 'image_views'), {
                    image_src: imageSrc,
                    view_duration: duration,
                    timestamp: serverTimestamp()
                });
                console.log('Image view saved to Firestore');
            } catch (error) {
                console.error('Error saving image view: ', error);
            }
        }
    </script>
</body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5W78LXJT"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
</html>